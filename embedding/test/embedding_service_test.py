""" Tests for CalledFunctions commands """

import math
import os
import sys
sys.path = [path for path in sys.path if "com_" not in path]
import tempfile
import unittest

import glog as log
import grpc
import grpc_testing
import numpy as np

from embedding.service import EmbeddingServiceServicer
import proto.embedding_pb2
import proto.embedding_pb2_grpc
import proto.get_graph_pb2
import proto.operations_pb2

class TestEmbeddingService(unittest.TestCase):
    """Tests for the EmbeddingService."""

    def setUp(self):
        servicers = {
            proto.embedding_pb2.DESCRIPTOR.services_by_name[
                "EmbeddingService"]: EmbeddingServiceServicer(),
        }
        self.server = grpc_testing.server_from_dictionary(
            servicers, grpc_testing.strict_real_time())
        self.uri_scheme = proto.operations_pb2.Scheme.SCHEME_FILE
        self.embedding_uri = proto.operations_pb2.Uri(
            scheme=self.uri_scheme,
            authority=None,
            path=os.path.abspath(
                "testdata/embeddings/"
                "libcapstone.so.4.reg2mem.bc.icfg.walks.embedding"),
        )
        self.walk_uri = proto.operations_pb2.Uri(
            scheme=self.uri_scheme,
            authority=None,
            path=os.path.abspath(
                "testdata/embeddings/libcapstone.so.4.reg2mem.bc.icfg.walks"),
        )
        self.bad_uri = proto.operations_pb2.Uri(
            scheme=self.uri_scheme,
            authority=None,
            path="thisisnotarealpath",
        )
        self.embedding_id = \
            "9049f63ac9017c875aabefcd5e8eed3b6fe64097a9c761a83c137bf39c62b9c5"
        self.labels = (proto.get_graph_pb2.Label(label="getRegisterName"),
                       proto.get_graph_pb2.Label(label="relative8_hdlr"))

    def __generate_tmp_uri(self):
        """Generates a URI protobuf message for a temporary file."""

        return proto.operations_pb2.Uri(
            scheme=self.uri_scheme,
            authority=None,
            path=os.path.abspath(tempfile.mktemp()),
        )

    def test_train_w2v(self):
        """Tests the Train() gRPC using Word2Vec."""

        # Generating a temporary file for the embedding.
        output_uri = self.__generate_tmp_uri()

        # Creating Train request using Word2Vec.
        request = proto.embedding_pb2.TrainRequest(
            random_walks_uri=self.walk_uri,
            output_embedding_uri=output_uri,
            embedding_method=
            proto.embedding_pb2.EmbeddingMethod.EMBEDDING_METHOD_WORD2VEC,
            dimensions=100,
            window=1,
            mincount=1,
        )

        # Invoking Train.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["Train"]),
            invocation_metadata={},
            request=request, timeout=None)

        response, *_ = invocation.termination()

        # The embedding ID that is returned from this will be random
        # because the embedding generated by w2v is random, meaning
        # that the hash will never be the same per run. We instead
        # just check that a embedding ID was produced, meaning that a
        # embedding was generated.
        assert response.embedding_id.id

        os.unlink(output_uri.path)

    def test_train_fasttext(self):
        """Tests the Train() gRPC using fastText."""

        # Generating a temporary file for the embedding.
        output_uri = self.__generate_tmp_uri()

        # Creating Train request using Word2Vec.
        request = proto.embedding_pb2.TrainRequest(
            random_walks_uri=self.walk_uri,
            output_embedding_uri=output_uri,
            embedding_method=
            proto.embedding_pb2.EmbeddingMethod.EMBEDDING_METHOD_FASTTEXT,
            dimensions=100,
            window=1,
            mincount=1,
        )

        # Invoking Train.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["Train"]),
            invocation_metadata={},
            request=request, timeout=None)

        response, *_ = invocation.termination()

        # The embedding ID that is returned from this will be random
        # because the embedding generated by fastText is random, meaning
        # that the hash will never be the same per run. We instead
        # just check that a embedding ID was produced, meaning that a
        # embedding was generated.
        assert response.embedding_id.id

        os.unlink(output_uri.path)

    def test_train_w2v_bad_uri(self):
        """Tests the Train() gRPC using Word2Vec with a bad URI."""

        # Generating a temporary file for the embedding.
        # This won't ever get populated as the Train
        # request won't actually ever make a successful
        # embedding.
        output_uri = self.__generate_tmp_uri()

        # Creating Train request.
        request = proto.embedding_pb2.TrainRequest(
            random_walks_uri=self.bad_uri,
            output_embedding_uri=output_uri,
            embedding_method=
            proto.embedding_pb2.EmbeddingMethod.EMBEDDING_METHOD_WORD2VEC,
            dimensions=100,
            window=1,
            mincount=1,
        )

        # Invoking Train.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["Train"]),
            invocation_metadata={},
            request=request, timeout=None)

        # Response should be empty and status code should be NOT_FOUND.
        _, _, context, *_ = invocation.termination()

        assert context is grpc.StatusCode.NOT_FOUND

    def test_train_fasttext_bad_uri(self):
        """Tests the Train() gRPC using fastText with a bad URI."""

        # Generating a temporary file for the embedding.
        # This won't ever get populated as the Train
        # request won't actually ever make a successful
        # embedding.
        output_uri = self.__generate_tmp_uri()

        # Creating Train request.
        request = proto.embedding_pb2.TrainRequest(
            random_walks_uri=self.bad_uri,
            output_embedding_uri=output_uri,
            embedding_method=
            proto.embedding_pb2.EmbeddingMethod.EMBEDDING_METHOD_FASTTEXT,
            dimensions=100,
            window=1,
            mincount=1,
        )

        # Invoking Train.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["Train"]),
            invocation_metadata={},
            request=request, timeout=None)

        # Response should be empty and status code should be NOT_FOUND.
        _, _, context, *_ = invocation.termination()

        assert context is grpc.StatusCode.NOT_FOUND


    def test_register_embedding(self):
        """Tests the RegisterEmbedding gRPC service."""

        # Creating RegisterEmbeddingRequest.
        request = proto.embedding_pb2.RegisterEmbeddingRequest(
            uri=self.embedding_uri)

        # Invoking RegisterEmbedding.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["RegisterEmbedding"]),
            invocation_metadata={},
            request=request, timeout=None)

        response, *_ = invocation.termination()

        assert response.embedding_id.id == self.embedding_id

    def test_register_embedding_bad_uri(self):
        """Tests the RegisterEmbedding gRPC service with a bad URI."""

        # Creating RegisterEmbeddingRequest.
        request = proto.embedding_pb2.RegisterEmbeddingRequest(
            uri=self.bad_uri)

        # Invoking RegisterEmbedding.
        invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["RegisterEmbedding"]),
            invocation_metadata={},
            request=request, timeout=None)

        # Response should be empty and status code should be NOT_FOUND.
        _, _, context, *_ = invocation.termination()

        assert context is grpc.StatusCode.NOT_FOUND

    def test_get_similarity(self):
        """Tests the GetSimilarity() gRPC service."""

        # The expected similarity.
        similarity = 0.01473537739366293
        # Need to first register the embedding.
        register_request = proto.embedding_pb2.RegisterEmbeddingRequest(
            uri=self.embedding_uri)

        # Invoking RegisterEmbedding.
        register_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["RegisterEmbedding"]),
            invocation_metadata={},
            request=register_request, timeout=None)
        # Getting the register response.
        register_response, *_ = register_invocation.termination()

        # Creating the GetSimilarity request.
        similarity_request = proto.embedding_pb2.GetSimilarityRequest(
            embedding_id=register_response.embedding_id,
            label1=self.labels[0],
            label2=self.labels[1],
        )

        # Invoking GetSimilarity.
        similarity_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["GetSimilarity"]),
            invocation_metadata={},
            request=similarity_request, timeout=None)

        similarity_response, *_ = similarity_invocation.termination()

        log.info("SIMILARITY: {}".format(similarity))
        log.info(
            "SIMILARITY RESPONSE: {}".format(similarity_response.similarity))
        assert math.isclose(
            similarity, similarity_response.similarity, abs_tol=0.0001)

    def test_get_most_similar(self):
        """Tests the GetMostSimilar() gRPC service."""

        # The expected similarity scores.
        similar_scores = \
            (0.9019336700439453, 0.8672118782997131, 0.8343673944473267)
        # The expected similar labels.
        similar_labels = ("printRegPair", "printcrbitm", "printRegisterPair")

        # Need to first register the embedding.
        register_request = proto.embedding_pb2.RegisterEmbeddingRequest(
            uri=self.embedding_uri)

        register_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["RegisterEmbedding"]),
            invocation_metadata={},
            request=register_request, timeout=None)
        # Getting the register response.
        register_response, *_ = register_invocation.termination()

        # Creating the GetMostSimilar request.
        similar_request = proto.embedding_pb2.GetMostSimilarRequest(
            embedding_id=register_response.embedding_id,
            label=self.labels[0],
            top_k=3,
        )

        # Invoking GetMostSimilar.
        similar_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["GetMostSimilar"]),
            invocation_metadata={},
            request=similar_request, timeout=None)

        similar_response, *_ = similar_invocation.termination()

        # Checking that scores match.
        for score in similar_response.similarities:
            # Using np.any for FP rounding error.
            assert np.any(np.isclose(score, similar_scores)) 

        # Checking that the label names match.
        for label in similar_response.labels:
            assert label.label in similar_labels

    def test_get_vocab(self):
        """Tests the GetVocabulary() gRPC service."""

        register_request = proto.embedding_pb2.RegisterEmbeddingRequest(
            uri=self.embedding_uri)

        # The embedding must be registered with the service first.
        register_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["RegisterEmbedding"]),
            invocation_metadata={},
            request=register_request, timeout=None)

        # Getting the register response.
        register_response, *_ = register_invocation.termination()

        vocab_request = proto.embedding_pb2.GetVocabularyRequest(
            embedding_id=register_response.embedding_id)

        vocab_invocation = self.server.invoke_unary_unary(
            method_descriptor=(
                proto.embedding_pb2.DESCRIPTOR
                .services_by_name["EmbeddingService"]
                .methods_by_name["GetVocabulary"]),
            invocation_metadata={},
            request=vocab_request, timeout=None)

        vocab_response, *_ = vocab_invocation.termination()

        assert len(vocab_response.function_labels) == 1070

if __name__ == "__main__":
    unittest.main()
